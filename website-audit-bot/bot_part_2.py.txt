# bot_part_2.py - –ß–∞—Å—Ç—å 2/7
# –§—É–Ω–∫—Ü–∏–∏: check_website, check_ssl, check_mobile

import requests
import ssl
import socket
import time
from urllib.parse import urlparse

def check_website(url):
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å, —Å–∫–æ—Ä–æ—Å—Ç—å, —Ä–∞–∑–º–µ—Ä, –∑–∞–≥–æ–ª–æ–≤–∫–∏, –∫–æ–¥–∏—Ä–æ–≤–∫—É.
    """
    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ–º https://, –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–æ
    if not url.startswith(("http://", "https://")):
        url = "https://" + url

    try:
        start_time = time.time()
        response = requests.get(
            url,
            timeout=10,
            headers={
                "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36"
            },
            allow_redirects=True
        )
        load_time = round(time.time() - start_time, 2)
        status_code = response.status_code
        is_ok = status_code == 200

        try:
            size_kb = round(len(response.content) / 1024, 2)
        except:
            size_kb = "N/A"

        content_type = response.headers.get("Content-Type", "").lower()
        charset_ok = "utf-8" in content_type

        return {
            "url": url,
            "is_ok": is_ok,
            "status": "‚úÖ –†–∞–±–æ—Ç–∞–µ—Ç" if is_ok else f"‚ùå –û—à–∏–±–∫–∞ {status_code}",
            "status_code": status_code,
            "load_time": f"{load_time} —Å–µ–∫",
            "size_kb": size_kb,
            "headers": dict(response.headers),
            "charset_ok": charset_ok,
            "error": None
        }

    except requests.exceptions.Timeout:
        return {
            "url": url,
            "is_ok": False,
            "status": "üî¥ –¢–∞–π–º–∞—É—Ç",
            "error": "–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è",
            "load_time": "N/A",
            "size_kb": "N/A"
        }

    except requests.exceptions.ConnectionError:
        return {
            "url": url,
            "is_ok": False,
            "status": "üî¥ –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è",
            "error": "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É",
            "load_time": "N/A",
            "size_kb": "N/A"
        }

    except Exception as e:
        return {
            "url": url,
            "is_ok": False,
            "status": "üî¥ –û—à–∏–±–∫–∞",
            "error": str(e),
            "load_time": "N/A",
            "size_kb": "N/A"
        }


def check_ssl(url):
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å SSL-—Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞.
    """
    if not url.startswith("https://"):
        return {"valid": False, "error": "HTTP"}

    try:
        parsed = urlparse(url)
        hostname = parsed.netloc.split(":")[0]

        context = ssl.create_default_context()
        with socket.create_connection((hostname, 443), timeout=10) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                cert = ssock.getpeercert()

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è
        from datetime import datetime
        not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
        is_valid = not_after > datetime.now()

        return {
            "valid": is_valid,
            "valid_to": not_after.strftime("%d.%m.%Y"),
            "error": None
        }

    except Exception as e:
        return {
            "valid": False,
            "error": str(e)
        }


def check_mobile(url):
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å–∞–π—Ç —Å User-Agent –º–æ–±–∏–ª—å–Ω–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞.
    """
    if not url.startswith(("http://", "https://")):
        url = "https://" + url

    mobile_headers = {
        "User-Agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15"
    }

    try:
        start_time = time.time()
        response = requests.get(url, headers=mobile_headers, timeout=10, allow_redirects=True)
        load_time = round(time.time() - start_time, 2)

        try:
            size_kb = round(len(response.content) / 1024, 2)
        except:
            size_kb = "N/A"

        return {
            "url": url,
            "load_time": f"{load_time} —Å–µ–∫",
            "size_kb": size_kb,
            "is_ok": response.status_code == 200,
            "status_code": response.status_code,
            "error": None
        }

    except Exception as e:
        return {
            "url": url,
            "load_time": "N/A",
            "size_kb": "N/A",
            "is_ok": False,
            "error": str(e)
        }